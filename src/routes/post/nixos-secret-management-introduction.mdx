---
date: 2024-09-29T19:13:48.385245919+08:00
description: Most NixOS Secret Management Tools In Common
categories:
  - 简介
tags:
  - security
  - NixOS
  - sops-nix
  - agenix
  - agenix-rekey
  - vaultix
draft: false
title: NixOS 不见光凭据管理综述
---

# Overview

> 下文区分凭据 (secret, credential) 密钥 (key / identity) 加密凭据 (crypted secret)。

前置知识：
+ 了解nix是干嘛用的
+ 会写nix配置
+ 部署过nixos

在 NixOS 储存凭据相比其它发行版有些比较特殊的难点：

+ nix 的系统配置在重新构建(rebuild) 的时候，为了确保纯净[^1](pure)，nix配置中使用的文件路径都必须[^2]存在 nix store 中，所以 nix 配置在求值(eval)的时候会将整个配置仓库复制进nix store
+ nix store 是全局可读的，任何在你系统上运行的代码都有权限读取。
+ 部分应用运行所需要的凭据不应该被全局可读(如 ssh private key )
+ 应用需要使用nix配置



## 限制

+ 不能将明文密码以字符串字面量写入配置文件

  否则在本地全局可读
+ 不能将明文密码存入文件，放在配置仓库以外的地方，并在nix配置中使用 `builtins.readFile`
  
  它会导致impure并且将明文密码写入nix store，与上一条没有区别

## 我们可以：

<div id="point"/>
+ 在nix配置中使用字符串(str)绝对路径，指向配置仓库外存有明文密码的文件

  缺点：配置仓库现在无法直接复现全部配置了，重新部署需要手动复制仓库外的明文凭据。而且绝对路径维护麻烦

+ 使用凭据管理方案

  缺点：学习成本++

  优点：明文凭据不落盘, 一般解密到不进行swap的ramfs

以下用两种主流的nixos凭据管理方案 (sops-nix, agenix) 为例，总结一些nix上凭据管理方案的通用规律。

# 原理


如[**上文**](#point)所述，凭据管理工具把明文凭据加密后存在配置仓库中，在deploy(rebuild)或者开机的时候<C>在nixos中此步骤一般成为activate，凭据的部署由`activationScript`或`systemd`实现</C>解密到固定的路径。

为了实现在多个nixosConfigurations 时「一个host的加密凭据不能被另一个host解密」，需要每个设备具备不一样的密钥用于加密。有个自然的选择：ssh host key。

凭据管理通常需要有两个密钥对:

+ 在每个 host 都不同的 identity(在有些方案中可能多个host共用一个): **per host identity**

  用来给被部署的host在部署凭据时用于解密（被部署端存有私钥, 即ssh host private key），通常位于 `/etc/ssh/ssh_host_id_ed25519_key`

+ 一个独立的identity: **admin identity**

  部署者(user)使用其加密明文凭据，然后将加密后的凭据储存在 nix store 或者其他地方(例如agenix-rekey 就可以直接储存在配置仓库中)。

<Emph type="info">
如果是使用了 root on tmpfs 的配置，需要将 ssh host private key 的路径手动写成 persist bindmount source 的绝对路径，如`/persist/etc/ssh/ssh_host_id_ed25519_key`, 否则可能遇到顺序问题
</Emph>

## Rekey

一般的流程是，用户在本地通过**admin identity** (的公钥)加密并储存凭据，

部署前在执行部署的一端(Deployer)<C>如运行 `nixos-rebuild ... --target ...` 的一端</C>
或者在被部署的一端(target)上<C>取决于各个工具的实现方式</C>使用 admin identity 解密，并将解密的数据使用 host identity 公钥加密，再在target使用 host identity 解密。



## 以 sops-nix 为例

如 sops-nix 使用 (gpg或age) admin identity 和 target 的 (gpg或age) 公钥在本地加密储存凭据，
编辑加密凭据时使用admin identity，部署时传输加密的内容，在对应 target 使用相应的 (gpg或age) 私钥解密

在sops-nix里面per host identity是通过 ssh-keyscan 或者直接读`/etc/ssh`获取, 如

```console
$ nix-shell -p ssh-to-age --run 'ssh-keyscan example.com | ssh-to-age'
age1rgffpespcyjn0d8jglk7km9kfrfhdyev6camd3rck6pn8y47ze4sug23v3
$ nix-shell -p ssh-to-age --run 'cat /etc/ssh/ssh_host_ed25519_key.pub | ssh-to-age'
age1rgffpespcyjn0d8jglk7km9kfrfhdyev6camd3rck6pn8y47ze4sug23v3
```

然后通过可选的转换步骤后放在[这里](https://github.com/Mic92/sops-nix/blob/127a96f49ddc377be6ba76964411bab11ae27803/README.md?plain=1#L249) ，无论是gpg还是age都是从 per server的host public key [derive](https://github.com/Mic92/sops-nix/blob/127a96f49ddc377be6ba76964411bab11ae27803/README.md?plain=1#L222)出来的。后者用户自己[生成](https://github.com/Mic92/sops-nix/blob/127a96f49ddc377be6ba76964411bab11ae27803/README.md?plain=1#L118) 然后放在[这里](https://github.com/Mic92/sops-nix/blob/127a96f49ddc377be6ba76964411bab11ae27803/README.md?plain=1#L248) 。

当然另有完全GPG的配置方法，但是过于老旧不赘述，不过是上文per host identity换成GPG密钥，目标机器解密的时候读GPG home（太。。了）


配置完成后的sops配置文件:

```yaml title=".sops.yaml"
keys:
  - &server_nosaxa age1rgffpespcyjn0d8jglk7km9kfrfhdyev6camd3rck6pn8y47ze4sug23v3
  - &admin_bob age12zlz6lvcdk6eqaewfylg35w0syh58sm7gh53q5vvn7hd7c6nngyseftjxl
creation_rules:
  - path_regex: secrets/[^/]+\.(yaml|json|env|ini)$
    key_groups:
      age:
      - *admin_bob
      - *server_nosaxa
```

代表 `secrets/[^/]+\.(yaml|json|env|ini)$` 下的路径可以被 `server_nosaxa` 和 `admin_bob` 的私钥解密。

而编辑仓库中储存的密钥所使用的(`admin identity`)是 `age.keyFile` (忘了gpg吧) 所设定的私钥文件。即[第二步](https://github.com/Mic92/sops-nix/blob/472741cf3fee089241ac9ea705bb2b9e0bfa2978/README.md?plain=1#L118)中生成的密钥

## 以agenix为例

再考虑如下agenix配置

```nix
let
  user1 = "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIL0idNvgGiucWgup/mP78zyC23uFjYq0evcWdjGQUaBH";
  user2 = "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAILI6jSq53F/3hEmSs+oq9L4TwOo1PrDMAgcA1uo1CCV/";
  users = [ user1 user2 ];

  system1 = "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIPJDyIr/FSz1cJdcoW69R+NrWzwGK/+3gJpqD1t8L2zE";
  system2 = "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIKzxQgondgEYcLpcPdJLrTdNgZ2gznOHCAxMdaceTUT1";
  systems = [ system1 system2 ];
in
{
  "secret1.age".publicKeys = [ user1 system1 ];
  "secret2.age".publicKeys = users ++ systems;
}
```

user 和 system prefix 的公钥就对应上文描述的 `admin identity` 和 `per host identity`。

相比sops-nix我可能更喜欢agenix。

# 现有方案对比

见 [wiki](https://wiki.nixos.org/wiki/Comparison_of_secret_managing_schemes#:~:text=a%20blog%20entry-,Comparison,-In%20case%20this)


[^1]: 即函数式的纯净性，1.给定相同的输入，总是返回相同的输出。也就是说，函数的输出只取决于输入，不受外部状态的影响。2.没有副作用。 函数不会修改外部的状态，包括全局变量、数据结构或输入参数。
[^2]: 可以额外添加 `--impure` 来继续构建。
